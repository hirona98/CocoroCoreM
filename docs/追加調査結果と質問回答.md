# CocoroCore2 追加調査結果と質問回答

## 調査完了サマリー

参考コード、CocoroDockソースコード、DefaultSetting.jsonの調査により、CocoroCore2の実装に必要な詳細仕様が明確になりました。

## ユーザー疑問点への回答

### 既存のMemOS APIを活用するか、独自実装するか？

**推奨回答**: **MemOS APIを最大限活用し、CocoroAI固有機能のみ独自実装**

**理由**:
1. **CocoroDockの通信仕様調査結果**により、以下のエンドポイントが必要：
   - `POST /api/memos/chat/stream` - MemOSのストリーミングチャット機能
   - `GET /api/users` - MemOSのユーザー管理機能
   - `GET /api/memory/user/{userId}/stats` - MemOS統計機能
   - `DELETE /api/memory/user/{userId}/all` - MemOS記憶削除機能

2. **参考コードのconfig.py**で`generate_memos_config_from_setting()`によりSetting.jsonからMemOS設定を動的生成する仕組みが実装済み

3. MemOSの`product_router.py`のエンドポイントを/apiプレフィックスに変更して流用可能

**実装方針**:
```python
# CocoroCore2のAPI設計
# ├── /health (独自実装)
# ├── /api/control (独自実装) 
# ├── /api/mcp/tool-registration-log (独自実装)
# ├── /api/users (MemOS product_router流用)
# ├── /api/memory/user/{user_id}/stats (MemOS product_router流用)
# ├── /api/memory/user/{user_id}/all (MemOS product_router流用)
# └── /api/memos/chat/stream (MemOS + 画像処理拡張)
```

● 基本的には推奨どおりで問題ありません。ただし、CocoroDockに無理に合わせる必要はありません。CocoroDockの仕様はいくらでも変更可能です。CocoroCore2にとって自然な仕様にしてください。
● /health だけ /api の下にないですが、特別な理由がなければ他に合わせて /api の下にしてください。


### データベース設定について

**回答**: **SQLite + Neo4j の組み合わせを使用**

**詳細**:
1. **参考コードの調査結果**:
   - `config.py`の`load_neo4j_config()`でNeo4j設定を動的生成
   - MemOSはSQLiteをデフォルトユーザー管理に使用
   - 高度なグラフ記憶にNeo4jを使用

2. **必要な設定**:
   ```json
   {
     "cocoroMemoryDBPort": 55603,    // Neo4j bolt接続ポート
     "cocoroMemoryWebPort": 55606,   // Neo4j Web UI ポート
     "characterList": [
       {
         "isEnableMemory": true,     // Neo4j使用可否
         "userId": "tsukuyomichan"   // MemCubeID
       }
     ]
   }
   ```

● OKです。

### メッセージタイプの処理方法

**推奨方式**: **参考コードのmodels.pyで定義済みの方式を採用**

**実装仕様**:
```python
# ImageContext (models.py参照)
source_type: Literal["chat", "notification", "desktop_monitoring"]

# 処理分岐:
if source_type == "chat":
    # 通常チャット: MOSProductのchat_with_references()を直接使用
elif source_type == "notification": 
    # 通知: MessageGenerator.generate_notification_message()
    # 画像あり/なしの両対応
elif source_type == "desktop_monitoring":
    # デスクトップ監視: MessageGenerator.generate_desktop_monitoring_message()
    # 必ず画像あり
```

● 推奨どおりで問題ありません

### オプショナル依存関係の詳細

**推奨セット**: 
```bash
pip install MemoryOS[tree-mem,mem-reader]
```

**詳細説明**:
1. **tree-mem**: Neo4jベースのTreeTextMemory（必須）
   - 高度なグラフ記憶機能
   - 参考コードでisEnableMemory=trueの場合に使用

2. **mem-reader**: ドキュメント読み込み機能（推奨）
   - PDFやテキストファイルの記憶化
   - 参考コードでMemReader機能として設定

3. **mem-scheduler**: メモリスケジューラー（標準で有効）
   - 参考コードで常に有効に設定済み

● OKです。

## 新たに発見した重要事項

### 1. 画像処理アーキテクチャ

**参考コードのanalyzer.py調査結果**:
- OpenAI Vision APIを使用した画像分析システム
- Base64エンコード画像の複数枚同時処理
- 構造化された分析結果（description, category, mood, time）

**実装必要事項**:
```python
# 画像処理フロー
1. CocoroDockからBase64画像を受信
2. ImageAnalyzer.analyze_image()で分析
3. 分析結果をMemOSに統合してチャット処理
4. MessageGeneratorで適切なレスポンス生成
```

### 2. ストリーミングAPI仕様

**CocoroCoreClient.cs調査結果**:
- **Server-Sent Events**形式でのリアルタイムストリーミング
- **Content-Type**: `text/event-stream`
- **データ形式**: `data: {"type": "text", "data": "content"}\n\n`

**実装必要事項**:
```python
@app.post("/api/memos/chat/stream")
async def streaming_chat():
    # MemOSProduct.chat_with_references()のジェネレータを
    # Server-Sent Events形式でストリーミング配信
```

● 他とURIのルールが違いませんか？合わせていいですよ。

### 3. 設定管理システム

**参考コードのconfig.py調査結果**:
- Setting.json → MOSConfig動的変換機能
- PyInstaller対応の設定ファイル自動検索
- 環境変数置換機能（${VAR_NAME}形式）

## 最終設計推奨事項

### アーキテクチャ構成
```python
# CocoroCore2/src/
# ├── main.py                    # FastAPI アプリケーション
# ├── core/
# │   ├── cocoro_product.py      # MOSProductラッパー
# │   ├── image_analyzer.py      # 参考コード流用
# │   ├── message_generator.py   # 参考コード流用
# │   └── config_manager.py      # 参考コード流用
# ├── api/
# │   ├── health.py             # ヘルスチェック
# │   ├── control.py            # システム制御
# │   ├── mcp.py                # MCP関連
# │   ├── memos_api.py          # MemOS統合エンドポイント
# │   └── streaming.py          # ストリーミングチャット
# └── models/
#     ├── cocoro_models.py      # CocoroAI固有モデル
#     └── api_models.py         # API共通モデル
```

### 依存関係管理
```python
# requirements.txt
MemoryOS[tree-mem,mem-reader]==1.0.0
fastapi>=0.104.0
uvicorn>=0.24.0
python-multipart>=0.0.6
Pillow>=10.0.0
```

### 設定ファイル統合
```json
// UserData2/Setting.json に以下を追加
{
  "cocoroCorePort": 55601,
  "cocoroMemoryDBPort": 55603,
  "cocoroMemoryWebPort": 55606,
  "enable_pro_mode": true,
  "enable_internet_retrieval": false,
  "enable_memory_scheduler": true,
  "multimodal_enabled": true,
  "max_image_size": 20000000,
  "characterList": [
    {
      "userId": "tsukuyomichan",
      "isEnableMemory": true,
      "apiKey": "your-openai-key",
      "llmModel": "gpt-4o-mini",
      "visionApiKey": "",
      "visionModel": "gpt-4o-mini",
      "embeddedApiKey": "",
      "embeddedModel": "text-embedding-3-small"
    }
  ]
}
```

## 追加質問事項

### 1. Neo4j自動起動について
**Q**: 組み込みNeo4jの自動起動をCocoroCore2内で実装するか、別プロセスとして管理するか？
- 参考コードでは`cocoroMemoryDBPort`での接続を前提としている
- PyInstallerパッケージング時の起動順序制御が必要

● やりやすい方にしてください。ただ、シーケンシャルに起動すると時間がかかるので非同期に起動してください。（接続のための待ち合わせに注意）

### 2. エラーハンドリング戦略
**Q**: MemOS統合エラー時のフォールバック処理をどこまで実装するか？
- 記憶機能無効時の通常チャット続行
- Neo4j接続失敗時の対応
- 画像分析失敗時の対応

● エラー発生時は、ログ出力してアプリを終了してください

### 3. ログ管理
**Q**: MemOSのログとCocoroCore2固有のログをどう統合するか？
- CocoroDockがログを期待している可能性
- デバッグ時の問題切り分け方法

● CocoroDockはログを期待しています。APIはCocoroDockを見てください。
● MemOSのログもCocoroCore2のログも同じ場所に出力してください
● CocoroDockでログ表示画面を開いたら、ログ転送をONにして、CocoroCore2からCocoroDockにリアルタイムでログを送信します。
● アプリ起動時は転送できないので最大300件まで保存しておき、初回のログ表示画面起動時にそれを転送する。200件以降からログ表示画面起動時までのログは捨てる。


### 4. パフォーマンス最適化
**Q**: 大量の画像処理時のメモリ管理とレスポンス時間の目標値は？
- Base64デコード時のメモリ使用量

● 100MB


- ストリーミング応答の遅延許容範囲

● トリッキーな方法を使わない範囲で速めにする


この調査結果により、CocoroCore2の実装設計が大幅に具体化されました。次のステップは上記の追加質問への回答をいただいてから、詳細実装設計に進むことをお勧めします。
